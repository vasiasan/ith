<html>
<head>
    <meta charset="utf-8">
    <title>Chessboard with Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- <script src="https://threejs.org/build/three.js"></script>
    <script src="https://unpkg.com/three-orbitcontrols@2.110.3/OrbitControls.js"></script> -->

        <script type="importmap">
          {
            "imports": {
              "three": "https://unpkg.com/three@v0.157.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@v0.157.0/examples/jsm/"
            }
          }
        </script>
        <script type="module">
          import * as THREE from 'three';
          import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
          import { FontLoader } from 'three/addons/loaders/FontLoader.js';
          import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // Scene, camera, and renderer setup
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();


        // Dark violet backgound
        renderer.setClearColor(0x110011);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls for camera
        var controls = new OrbitControls( camera, renderer.domElement );

        // Animation loop
        var animate = function () {
            requestAnimationFrame(animate);
            controls.update(); // Only required if controls.enableDamping = true, or if controls.autoRotate = true
            renderer.render(scene, camera);
        };

        animate();

        // Background stars
        class Stars {
            constructor(amount, distributionRadius) {
                this.starsAmount = amount;
                this.distributionRadius = distributionRadius;
            }
            draw() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsVertices = [];

                for (let i = 0; i < this.starsAmount; i++) {
                    const radius = 100 + Math.random() * (this.distributionRadius - 100);
                    const theta = Math.random() * 2 * Math.PI; // Угол от 0 до 2π
                    const phi = Math.acos(2 * Math.random() - 1); // Угол от 0 до π

                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    starsVertices.push(x, y, z);
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const starsMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1 });
                return new THREE.Points(starsGeometry, starsMaterial);
            }
        }        const stars = new Stars(10000, 1000);
        scene.add(stars.draw());

        class Sphere {
            constructor(){
                this.material = new THREE.MeshBasicMaterial({ color: 0xFF9900, transparent: true, opacity: 0.8 });
                this.geometry = new THREE.SphereGeometry(0.1, 16, 16); // Радиус 0.1, сегменты: 16

                this.sphere = new THREE.Mesh(this.geometry, this.material);
                this.sphere.position.y = 0.2; // y = 0.2, чтобы сфера была над доской

                return this.sphere;
            }
        }

        // Chessboard creation
        class Tile {
            model = new THREE.Group();
            board = null;
            figure = null;
            sphere = null;
            states = [];
            constructor(color, size, x, z){
                this.x = x;
                this.z = z;
                this.material = new THREE.MeshToonMaterial({color: color});
                this.geometry = new THREE.BoxGeometry(size, size * 0.6, size);
                this.tile = new THREE.Mesh(this.geometry, this.material)
                this.tile.position.y = -(size * 0.6 / 2);
                this.model.add(this.tile);
            }
            addMoveSphere(){
                if ( this.sphere ) return;
                this.sphere = new Sphere;
                this.model.add(this.sphere);
            }
            removeSphere(){
                this.model.remove(this.sphere);
                this.sphere = null;
            }

            addFigure (mech){
                this.figure = mech;
                this.model.add(mech.modelFull);
                mech.tile = this;
            }

            addState (state){
                this.states = state;
                this.model.add(state.model);
                state.tile = this;
            }
        }
        class Board {
            board = new THREE.Group()

            lightColor = 0xFFFFFF;
            darktColor = 0x000000;

            darkMaterial = new THREE.MeshToonMaterial({color: this.darktColor});

            tileSize = 1;
            tiles = [];

            selected = null;

            constructor(x, z){
                this.xSize = x;
                this.zSize = z;
                this.tileShiftX = x / 2 - this.tileSize / 2; // 3.5 for 8x8 board size and 1 of cell size
                this.tileShiftZ = z / 2 - this.tileSize / 2;

                for (var x = 0; x < this.xSize; x++) {
                    for (var z = 0; z < this.zSize; z++) {
                        var tileColor = (x + z) % 2 === 0 ? this.darktColor : this.lightColor;
                        var tile = new Tile(tileColor, this.tileSize, x, z);

                        // create first array element
                        if( z === 0 ){ this.tiles[x] = []; };
                        this.tiles[x][z] = tile;
                        tile.board = this;

                        var tileDrawn = tile.model;
                        tileDrawn.position.x = x - this.tileShiftX;
                        tileDrawn.position.z = z - this.tileShiftZ;
                        this.board.add(tileDrawn);
                    }
                }
                this.model = this.board;
            }

            isWithin (x,z){
                return x >= 0 && x < this.xSize && z >= 0 && z < this.zSize;
            }

            figures (){
                let models = [];
                for (var x = 0; x < this.xSize; x++) {
                    for (var z = 0; z < this.zSize; z++) {
                        if ( this.tiles[x][z].figure ){
                            models.push(this.tiles[x][z].figure)
                        }
                    }
                }
                return models;
            }

            tilesWithMoveSphere = [];

            possibleMoves (steps, x, z){
                let directions = [
                    [ x +1, z   ],
                    [ x -1, z   ],
                    [ x   , z +1],
                    [ x   , z -1]
                ];

                if (steps >= 1){
                    for ( let [dx, dz] of directions ){
                        if ( this.isWithin(dx,dz) && ! this.tiles[dx][dz].figure ) {

                            let tile = this.tiles[dx][dz];
                            if ( !tile.sphere && !tile.figure ){
                                let sphere = tile.addMoveSphere();
                                this.tilesWithMoveSphere.push(tile);
                            }
                            this.possibleMoves(steps -1, dx, dz);
                        }
                    }
                }
            }

            clearPossibleMoves() {
                this.tilesWithMoveSphere.forEach(tile => tile.removeSphere());
                this.tilesWithMoveSphere.length = 0; // Очищаем массив
            }
        };
        const board = new Board(8, 8);
        window.board = board;
        scene.add(board.model);

        // Mech's frame class
        class Frame {
            cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            cubeMaterial = new THREE.MeshStandardMaterial({color: 0x0000FF});

            constructor(){
                this.cube = new THREE.Mesh(this.cubeGeometry, this.cubeMaterial);
                this.cube.position.y = 0.5;

                this.model = this.cube;
            }
        }

        // Mech's weapon class
        class Tools {
            toolGeometry = new THREE.BoxGeometry(0.7, 0.2, 0.2);
            toolMaterial = new THREE.MeshStandardMaterial({color: 0xFF0000});

            tools = new THREE.Group();
            toolLeft  = new THREE.Mesh(this.toolGeometry, this.toolMaterial);
            toolRight = new THREE.Mesh(this.toolGeometry, this.toolMaterial);

            constructor (){
                this.toolLeft.position.z = -0.35;
                this.toolLeft.position.y = 0.6;
    
                this.toolRight.position.z = 0.35;
                this.toolRight.position.y = 0.6;
    
                this.tools.add(this.toolLeft);
                this.tools.add(this.toolRight);
                this.model = this.tools
            }
        }

        // Wheel class
        class Wheel {
            material = new THREE.MeshStandardMaterial({color: 0xff00ff});

            constructor (size){
                this.wheelGeometry = new THREE.CylinderGeometry(size, size, 0.3, 32);
                this.wheel = new THREE.Mesh(this.wheelGeometry, this.material);
                this.wheel.rotation.x = Math.PI / 2;
                this.model = this.wheel;
            }
        }

        // Chassis class
        class Chassis {

            wheelSize = 0.2;
            cellShift = 0.3;
            wheels = [];

            chassis = new THREE.Group();

            constructor (){
                
                for (let i of [+1, -1]) {
                    for (let j of [+1, -1]) {
                        let wheel = new Wheel(this.wheelSize);
                        wheel.model.position.x = i * this.cellShift;
                        wheel.model.position.z = j * this.cellShift;
                        wheel.model.position.y = this.wheelSize;
                        this.wheels.push(wheel);
                        this.chassis.add(wheel.model);
                    }
                }
                this.model = this.chassis;
            }
        }

        // Mech's class
        class Mech {
            mech = new THREE.Group();
            modelFull = new THREE.Group();
            tile = null;

            constructor (){
                this.model = this.mech;

                this.frame = new Frame();
                this.tools = new Tools();
                this.chassis = new Chassis();

                this.mech.add(this.frame.model);
                this.mech.add(this.tools.model);
                this.mech.add(this.chassis.model);

                this.selectorGeometry = new THREE.ConeGeometry(0.5, 1, 32);
                this.selectorMaterial = new THREE.MeshBasicMaterial({color: 0x00FF00, transparent: true, opacity: 0.7});
                this.selector = new THREE.Mesh(this.selectorGeometry, this.selectorMaterial);

                this.selector.position.y = 2;
                this.selector.rotation.x = Math.PI; // Перевернуть конус, чтобы он указывал вниз
                this.selector.visible = false; // По умолчанию конус невидим

                // Created to show all objects related to the mech
                this.modelFull.add(this.mech);
                this.modelFull.add(this.selector);
            } 

            select(){
                this.selector.visible = true;
                this.tile.board.possibleMoves(3, this.tile.x, this.tile.z);
            }
            deselect(){
                this.selector.visible = false;
                this.tile.board.clearPossibleMoves();
            }
        }

        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////// STATUSES ////////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////

        // Cloud
        class Cloud {
            model = new THREE.Group();
            cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });

            constructor(){
                this.sphereCount = 50;
                for (let i = 0; i < this.sphereCount; i++) {
                    this.sphereGeometry = new THREE.SphereGeometry(Math.random() * 0.4 + 0.01, 16, 16);
                    const sphere = new THREE.Mesh(this.sphereGeometry, this.cloudMaterial);
                    sphere.position.set(
                        Math.random() * 0.6 - 0.3,
                        Math.random() * 0.6 - 0.3,
                        Math.random() * 0.6 - 0.3
                    );
                    this.model.add(sphere);
                }
                this.model.position.y = 0.5;;
            }
        }

        // Fire
        class Fire {
            model = new THREE.Group();
            coneGeometry = new THREE.ConeGeometry(0.05, 0.28, 32);
            yellowMaterial = new THREE.MeshToonMaterial({color: 0xFFFF00,transparent: true,opacity: 0.9});
            redMaterial = new THREE.MeshToonMaterial({color: 0xFF0000,transparent: true,opacity: 0.9});
            bottomGeometry = new THREE.SphereGeometry(0.12, 32);

            constructor(){
                const flame = new THREE.Group();
                const cone1 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
                cone1.position.set( 0.048, 0.13,  0.048);
                const cone2 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
                cone2.position.set(-0.048, 0.13,  0.048);
                const cone3 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
                cone3.position.set( 0.048, 0.13, -0.048);
                const cone4 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
                cone4.position.set(-0.048, 0.13, -0.048);
                const cone5 = new THREE.Mesh(this.coneGeometry, this.redMaterial);
                cone5.position.set(0, 0.25, 0);

                const ball = new THREE.Mesh(this.bottomGeometry, this.redMaterial);

                flame.add(cone1);
                flame.add(cone2);
                flame.add(cone3);
                flame.add(cone4);
                flame.add(cone5);
                flame.add(ball);
                flame.position.x = +0.4;
                flame.position.z = -0.4;
                flame.position.y = 0.2;


                this.model.add(flame);

                const flame1 = flame.clone() 
                flame1.position.x = +0.4;
                flame1.position.z = +0.4;
                this.model.add(flame1);

                const flame2 = flame.clone() 
                flame2.position.x = -0.4;
                flame2.position.z = +0.4;
                this.model.add(flame2);

                const flame3 = flame.clone() 
                flame3.position.x = -0.4;
                flame3.position.z = -0.4;
                this.model.add(flame3);
            }
        }

        // create mech
        board.tiles[0][0].addFigure(new Mech());
        board.tiles[3][3].addFigure(new Mech());
        board.tiles[7][7].addState(new Cloud())
        board.tiles[5][5].addState(new Fire())

        window.addEventListener('click', onDocumentMouseClick, false);
        function onDocumentMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if ( board.selected ) {
                board.selected.deselect();
                board.selecter = null;
            }
            for (let f of board.figures()){
                let intersects = raycaster.intersectObjects(f.model.children);

                if (intersects.length > 0) {
                    f.select();
                    board.selected = f;
                    break;
                }
            }
        }

        // createStatuses(x, z){
        //         const xPos = x - 3.5;
        //         const zPos = z - 3.5;

        //         const statuses = new THREE.Group();
        //         // // WATER

        //         // const waterGeometry = new THREE.SphereGeometry(0.15, 32);
        //         // const waterMaterial = new THREE.MeshToonMaterial({color: 0x0000FF,transparent: true,opacity: 0.9});
        //         // const water = new THREE.Mesh(waterGeometry, waterMaterial);

        //         // water.position.x = xPos + 0.3;
        //         // water.position.z = zPos + 0.3;
        //         // water.position.y = 1;

        //         // statuses.add(water);
        //         return statuses;
        //     }

        const loader = new FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
    
            const textSize = 0.3;
            const textHeight = 0.05;
            const textMaterial = new THREE.MeshBasicMaterial({color: 0x333333});

            // Letters
            const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            letters.forEach((number, i) => {
                const textGeometry = new TextGeometry(number, {
                    font: font,
                    size: textSize,
                    height: textHeight,
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(-4, -0.4, i - 3.75);
                textMesh.rotation.y = Math.PI / -2;
                scene.add(textMesh);

                const textMesh2 = new THREE.Mesh(textGeometry, textMaterial);
                textMesh2.position.set(4.05, -0.4, i - 3.75);
                textMesh2.rotation.y = Math.PI / -2;
                scene.add(textMesh2);
            });

            // Digits
            const numbers = ['1', '2', '3', '4', '5', '6', '7', '8'];
            numbers.forEach((letter, i) => {
                const textGeometry = new TextGeometry(letter, {
                    font: font,
                    size: textSize,
                    height: textHeight,
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(i - 3.75, -0.4, -4.05);
                scene.add(textMesh);

                const textMesh2 = new THREE.Mesh(textGeometry, textMaterial);
                textMesh2.position.set(i - 3.75, -0.4, 4);
                scene.add(textMesh2);
            });
        });

        // Camera position
        camera.position.x = -7;
        camera.position.y = 7;
        camera.position.z = -7;
        camera.lookAt(scene.position);

        // Resize on window size change
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            // Обновление размеров камеры
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Обновление размеров рендерера
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        const light = new THREE.PointLight(0xFFFFFF, 70, 1000);
        light.position.set(0, 5, 0);
        scene.add(light);

    </script>
</body>
</html>
