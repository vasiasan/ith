<html>
<head>
    <meta charset="utf-8">
    <title>Into the Heroes</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- <script src="https://threejs.org/build/three.js"></script>
    <script src="https://unpkg.com/three-orbitcontrols@2.110.3/OrbitControls.js"></script> -->

        <script type="importmap">
          {
            "imports": {
              "three": "https://unpkg.com/three@v0.157.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@v0.157.0/examples/jsm/"
            }
          }
        </script>
        <script type="module">
          import * as THREE from 'three';
          import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
          import { FontLoader } from 'three/addons/loaders/FontLoader.js';
          import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // Scene, camera, and renderer setup
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();


        // Dark violet backgound
        renderer.setClearColor(0x110011);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls for camera
        var controls = new OrbitControls( camera, renderer.domElement );

        // Animation loop
        var animate = function () {
            requestAnimationFrame(animate);
            controls.update(); // Only required if controls.enableDamping = true, or if controls.autoRotate = true
            renderer.render(scene, camera);
        };

        animate();

        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        ///////////////////////////// STARS //////////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////

        // Background stars
        class Stars {
            constructor(amount, distributionRadius) {
                this.starsAmount = amount;
                this.distributionRadius = distributionRadius;
            }
            draw() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsVertices = [];

                for (let i = 0; i < this.starsAmount; i++) {
                    const radius = 100 + Math.random() * (this.distributionRadius - 100);
                    const theta = Math.random() * 2 * Math.PI; // Угол от 0 до 2π
                    const phi = Math.acos(2 * Math.random() - 1); // Угол от 0 до π

                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    starsVertices.push(x, y, z);
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const starsMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1 });
                return new THREE.Points(starsGeometry, starsMaterial);
            }
        }        const stars = new Stars(10000, 1000);
        scene.add(stars.draw());

        class Sphere {
            constructor(){
                this.material = new THREE.MeshBasicMaterial({ color: 0xFF9900, transparent: true, opacity: 0.8 });
                this.geometry = new THREE.SphereGeometry(0.1, 16, 16); // Радиус 0.1, сегменты: 16

                this.sphere = new THREE.Mesh(this.geometry, this.material);
                this.sphere.position.y = 0.1; // y = 0.2, чтобы сфера была над доской

                return this.sphere;
            }
        }

        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        ///////////////////////// BOARD AND TILE /////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////

        // Chessboard creation
        class Tile {
            model = new THREE.Group();
            board = null;
            figure = null;
            sphere = null;
            states = [];
            constructor(color, size, x, z){
                this.model.tileInstance = this;
                this.x = x;
                this.z = z;
                this.material = new THREE.MeshToonMaterial({color: color});
                this.geometry = new THREE.BoxGeometry(size, size * 0.6, size);
                this.tile = new THREE.Mesh(this.geometry, this.material)
                this.tile.position.y = -(size * 0.6 / 2);
                this.model.add(this.tile);
            }
            addMoveSphere(){
                if ( this.sphere ) return;
                this.sphere = new Sphere();
                this.model.add(this.sphere);
            }
            removeSphere(){
                this.model.remove(this.sphere);
                this.sphere = null;
            }

            addFigure (figure){
                this.figure = figure;
                this.model.add(figure.modelFull);
                figure.tile = this;
            }

            remFigure (){
                this.model.remove(this.figure.modelFull);
                this.figure.tile = null;
                this.figure = null;
            }

            addState (state){
                this.states = state;
                if (state instanceof Water){
                    this.material.color.set("#0000FF");
                } else if (state instanceof Abyss){
                    this.tile.visible = false;
                } else {
                    this.model.add(state.model);
                    state.model.tileInstance = this;
                    state.tile = this;
                }
            }
        }
        class Board {
            board = new THREE.Group()

            lightColor = 0xFFFFFF;
            darktColor = 0x000000;

            darkMaterial = new THREE.MeshToonMaterial({color: this.darktColor});

            tileSize = 1;
            tiles = [];

            selected = null;

            constructor(x, z){
                this.xSize = x;
                this.zSize = z;
                this.tileShiftX = x / 2 - this.tileSize / 2; // 3.5 for 8x8 board size and 1 of cell size
                this.tileShiftZ = z / 2 - this.tileSize / 2;

                for (var x = 0; x < this.xSize; x++) {
                    for (var z = 0; z < this.zSize; z++) {
                        var tileColor = (x + z) % 2 === 0 ? this.darktColor : this.lightColor;
                        var tile = new Tile(tileColor, this.tileSize, x, z);

                        // create first array element
                        if( z === 0 ){ this.tiles[x] = []; };
                        this.tiles[x][z] = tile;
                        tile.board = this;

                        var tileDrawn = tile.model;
                        tileDrawn.position.x = x - this.tileShiftX;
                        tileDrawn.position.z = z - this.tileShiftZ;
                        this.board.add(tileDrawn);
                    }
                }
                this.model = this.board;
            }

            isWithin (x,z){
                return x >= 0 && x < this.xSize && z >= 0 && z < this.zSize;
            }

            figures (){
                let models = [];
                for (var x = 0; x < this.xSize; x++) {
                    for (var z = 0; z < this.zSize; z++) {
                        if ( this.tiles[x][z].figure ){
                            models.push(this.tiles[x][z].figure)
                        }
                    }
                }
                return models;
            }

            move (figure, tile){
                figure.tile.remFigure();
                tile.addFigure(figure);
            }
            select(figure){
                this.selected = figure;
                figure.select();
            }
            deselect(){
                if (this.selected){
                    this.selected.deselect();
                }
                this.selected = null;
            }

            tilesWithMoveSphere = [];

            possibleMoves (steps, x, z){
                let directions = [
                    [ x +1, z   ],
                    [ x -1, z   ],
                    [ x   , z +1],
                    [ x   , z -1]
                ];

                if (steps >= 1){
                    for ( let [dx, dz] of directions ){
                        if ( this.isWithin(dx,dz) && ! this.tiles[dx][dz].figure ) {

                            let tile = this.tiles[dx][dz];
                            if ( !tile.sphere && !tile.figure ){
                                let sphere = tile.addMoveSphere();
                                this.tilesWithMoveSphere.push(tile);
                            }
                            this.possibleMoves(steps -1, dx, dz);
                        }
                    }
                }
            }

            clearPossibleMoves() {
                this.tilesWithMoveSphere.forEach(tile => tile.removeSphere());
                this.tilesWithMoveSphere.length = 0; // Очищаем массив
            }
        };
        const board = new Board(8, 8);
        window.board = board;
        scene.add(board.model);

        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        ///////////////////////// FIGURE'S PARTS /////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////

        // Figure's frame class
        class Frame {
            model = new THREE.Group();
            cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            cubeMaterial = new THREE.MeshStandardMaterial({color: 0x0000FF});

            constructor(){
                this.cube = new THREE.Mesh(this.cubeGeometry, this.cubeMaterial);
                this.cube.position.y = 0.5;

                this.model.add(this.cube);
            }
        }

        // Figure's weapon class
        class Tools {
            toolGeometry = new THREE.BoxGeometry(0.7, 0.2, 0.2);
            toolMaterial = new THREE.MeshStandardMaterial({color: 0xFF0000});

            tools = new THREE.Group();
            toolLeft  = new THREE.Mesh(this.toolGeometry, this.toolMaterial);
            toolRight = new THREE.Mesh(this.toolGeometry, this.toolMaterial);

            constructor (){
                this.toolLeft.position.z = -0.35;
                this.toolLeft.position.y = 0.6;
    
                this.toolRight.position.z = 0.35;
                this.toolRight.position.y = 0.6;
    
                this.tools.add(this.toolLeft);
                this.tools.add(this.toolRight);
                this.model = this.tools
            }
        }

        // Wheel class
        class Wheel {
            material = new THREE.MeshStandardMaterial({color: 0xff00ff});

            constructor (size){
                this.wheelGeometry = new THREE.CylinderGeometry(size, size, 0.3, 32);
                this.wheel = new THREE.Mesh(this.wheelGeometry, this.material);
                this.wheel.rotation.x = Math.PI / 2;
                this.model = this.wheel;
            }
        }

        // Chassis class
        class Chassis {

            wheelSize = 0.2;
            cellShift = 0.3;
            wheels = [];

            chassis = new THREE.Group();

            constructor (){
                
                for (let i of [+1, -1]) {
                    for (let j of [+1, -1]) {
                        let wheel = new Wheel(this.wheelSize);
                        wheel.model.position.x = i * this.cellShift;
                        wheel.model.position.z = j * this.cellShift;
                        wheel.model.position.y = this.wheelSize;
                        this.wheels.push(wheel);
                        this.chassis.add(wheel.model);
                    }
                }
                this.model = this.chassis;
            }
        }

        // Selector for figure
        class Selector {
            selectorGeometry = new THREE.ConeGeometry(0.5, 1, 32);
            selectorMaterial = new THREE.MeshBasicMaterial({color: 0x00FF00, transparent: true, opacity: 0.7});
            constructor(){
                this.model = new THREE.Mesh(this.selectorGeometry, this.selectorMaterial);

                this.model.position.y = 2;
                this.model.rotation.x = Math.PI; // Перевернуть конус, чтобы он указывал вниз
            }
        }
        // Figure's class
        class Figure {
            model = new THREE.Group();
            modelFull = new THREE.Group();
            tile = null;
            selector = null;

            constructor (){
                this.frame = new Frame();
                this.frame.model.figureInstance = this;       // Need to use in click intersections

                this.tools = new Tools();
                this.tools.model.figureInstance = this;       // Need to use in click intersections

                this.chassis = new Chassis();
                this.chassis.model.figureInstance = this;     // Need to use in click intersections

                this.model.add(this.frame.model);
                this.model.add(this.tools.model);
                this.model.add(this.chassis.model);

                this.modelFull.add(this.model);
            } 

            select(){
                // Created to show all UNCLICKABLE objects related to the figure
                this.selector = new Selector();
                this.modelFull.add(this.selector.model);

                this.tile.board.possibleMoves(3, this.tile.x, this.tile.z);
            }
            deselect(){
                this.modelFull.remove(this.selector.model);
                this.selector = null;

                this.tile.board.clearPossibleMoves();
            }
        }

        // Fire
        // class Fire {
        //     model = new THREE.Group();
        //     coneGeometry = new THREE.ConeGeometry(0.05, 0.28, 32);
        //     yellowMaterial = new THREE.MeshToonMaterial({color: 0xFFFF00,transparent: true,opacity: 0.9});
        //     redMaterial = new THREE.MeshToonMaterial({color: 0xFF0000,transparent: true,opacity: 0.9});
        //     bottomGeometry = new THREE.SphereGeometry(0.12, 32);

        //     constructor(){
        //         const flame = new THREE.Group();
        //         const cone1 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
        //         cone1.position.set( 0.048, 0.13,  0.048);
        //         const cone2 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
        //         cone2.position.set(-0.048, 0.13,  0.048);
        //         const cone3 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
        //         cone3.position.set( 0.048, 0.13, -0.048);
        //         const cone4 = new THREE.Mesh(this.coneGeometry, this.yellowMaterial);
        //         cone4.position.set(-0.048, 0.13, -0.048);
        //         const cone5 = new THREE.Mesh(this.coneGeometry, this.redMaterial);
        //         cone5.position.set(0, 0.25, 0);

        //         const ball = new THREE.Mesh(this.bottomGeometry, this.redMaterial);

        //         flame.add(cone1);
        //         flame.add(cone2);
        //         flame.add(cone3);
        //         flame.add(cone4);
        //         flame.add(cone5);
        //         flame.add(ball);
        //         flame.position.x = +0.4;
        //         flame.position.z = -0.4;
        //         flame.position.y = 0.2;


        //         this.model.add(flame);

        //         const flame1 = flame.clone() 
        //         flame1.position.x = +0.4;
        //         flame1.position.z = +0.4;
        //         this.model.add(flame1);

        //         const flame2 = flame.clone() 
        //         flame2.position.x = -0.4;
        //         flame2.position.z = +0.4;
        //         this.model.add(flame2);

        //         const flame3 = flame.clone() 
        //         flame3.position.x = -0.4;
        //         flame3.position.z = -0.4;
        //         this.model.add(flame3);
        //     }
        // }

        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////// STATUSES ////////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////

        // Cloud
        class Cloud {
            model = new THREE.Group();
            cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });

            constructor(){
                this.sphereCount = 50;
                for (let i = 0; i < this.sphereCount; i++) {
                    this.sphereGeometry = new THREE.SphereGeometry(Math.random() * 0.4 + 0.01, 16, 16);
                    const sphere = new THREE.Mesh(this.sphereGeometry, this.cloudMaterial);
                    sphere.position.set(
                        Math.random() * 0.6 - 0.3,
                        Math.random() * 0.6 - 0.3,
                        Math.random() * 0.6 - 0.3
                    );
                    this.model.add(sphere);
                }
                this.model.position.y = 0.5;;
            }
        }

        class Fire {
            model = new THREE.Group();
            Geometries = [
                new THREE.ConeGeometry(0.1, 0.2, 32),
                new THREE.ConeGeometry(0.1, 0.3, 32),
                new THREE.ConeGeometry(0.1, 0.5, 32)
            ];

            Materials = [
                new THREE.MeshToonMaterial({color: 0xFFFF00,transparent: true,opacity: 0.9}),   // YELLOW
                new THREE.MeshToonMaterial({color: 0xFF0000,transparent: true,opacity: 0.9})    // RED
            ];

            constructor(){
                let amountOfFlames = 50;
                for (let f = 0; f < amountOfFlames; f++){
                    
                    const geometry = this.Geometries[ f % this.Geometries.length ];
                    const material = this.Materials[ f % this.Materials.length ];

                    const flame = new THREE.Mesh(geometry, material);

                    flame.position.set(
                        Math.random() * 0.8 - 0.4,
                        geometry.parameters.height/2,
                        Math.random() * 0.8 - 0.4
                        )

                    this.model.add(flame);
                }
            }
        }
        
        // WATER
        class Water {}

        // Abyss
        class Abyss {}

        // create figures
        board.tiles[0][0].addFigure(new Figure());
        board.tiles[3][3].addFigure(new Figure());
        board.tiles[7][7].addState(new Cloud())
        board.tiles[5][5].addState(new Fire());
        board.tiles[3][3].addState(new Water());
        board.tiles[3][5].addState(new Abyss());

        board.move(board.tiles[3][3].figure, board.tiles[4][4]);


        let mouseDownCoords = { x: 0, y: 0 };
        document.addEventListener('mousedown', (event) => {
            mouseDownCoords.x = event.clientX;
            mouseDownCoords.y = event.clientY;
        });
        document.addEventListener('mouseup', onDocumentMouseClick, false);

        function onDocumentMouseClick(event) {
            const deltaX = event.clientX - mouseDownCoords.x;
            const deltaY = event.clientY - mouseDownCoords.y;
            if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                return; // Прекратить обработку
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // Находим пересечения со всеми моделями
            let intersects = raycaster.intersectObjects(scene.children, true);

            // Если есть пересечения, выбираем первое (ближайшее к камере)
            if (intersects.length > 0){
                const obj = intersects[0].object;
                // Click on figure
                if ( obj.parent.figureInstance ) {
                    board.deselect();
                    board.select(obj.parent.figureInstance);
                // Click on tile with figure
                } else if ( obj.parent.tileInstance && obj.parent.tileInstance.figure ) {
                    board.deselect();
                    board.select(obj.parent.tileInstance.figure);
                // Click on tile with possible move
                } else if (obj.parent.tileInstance && obj.parent.tileInstance.sphere) {
                    board.move( board.selected, obj.parent.tileInstance );
                    board.deselect();
                // Click on other objects
                } else if (board.selected) {
                    board.deselect();
                }
            // Click on background
            } else if (board.selected) {
                board.deselect();
            }

            // 
        }


        // let hoveredObject = null;
        // document.addEventListener('mousemove', onDocumentMouseMove);
        // function onDocumentMouseMove(event) {
        //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        //     raycaster.setFromCamera(mouse, camera);

        //     // Находим пересечения со всеми моделями
        //     let intersects = raycaster.intersectObjects(scene.children, true);

        //     // Если есть пересечения
        //     if (intersects.length > 0) {
        //         // Если это новый объект (не тот, над которым был курсор ранее)
        //         if (hoveredObject !== intersects[0].object) {
        //             if (hoveredObject) {
        //                 // Событие "mouseout" для предыдущего объекта
        //                 onObjectMouseOut(hoveredObject);
        //             }
        //             hoveredObject = intersects[0].object;
        //             // Событие "mouseover" для нового объекта
        //             onObjectMouseOver(hoveredObject);
        //         }
        //     } else if (hoveredObject) {
        //         // Событие "mouseout" для предыдущего объекта
        //         onObjectMouseOut(hoveredObject);
        //         hoveredObject = null;
        //     }
        // }

        // function onObjectMouseOver(obj) {
        //     // Действия при наведении курсора на объект
        //     console.log("Mouse over:", obj);
        // }

        // function onObjectMouseOut(obj) {
        //     // Действия при уходе курсора с объекта
        //     console.log("Mouse out:", obj);
        // }

        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        ////////////////////////// BOARD LEGEND //////////////////////////
        //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////
        const loader = new FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
    
            const textSize = 0.3;
            const textHeight = 0.05;
            const textMaterial = new THREE.MeshBasicMaterial({color: 0x333333});

            // Letters
            const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            letters.forEach((number, i) => {
                const textGeometry = new TextGeometry(number, {
                    font: font,
                    size: textSize,
                    height: textHeight,
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(-4, -0.4, i - 3.75);
                textMesh.rotation.y = Math.PI / -2;
                scene.add(textMesh);

                const textMesh2 = new THREE.Mesh(textGeometry, textMaterial);
                textMesh2.position.set(4.05, -0.4, i - 3.75);
                textMesh2.rotation.y = Math.PI / -2;
                scene.add(textMesh2);
            });

            // Digits
            const numbers = ['1', '2', '3', '4', '5', '6', '7', '8'];
            numbers.forEach((letter, i) => {
                const textGeometry = new TextGeometry(letter, {
                    font: font,
                    size: textSize,
                    height: textHeight,
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(i - 3.75, -0.4, -4.05);
                scene.add(textMesh);

                const textMesh2 = new THREE.Mesh(textGeometry, textMaterial);
                textMesh2.position.set(i - 3.75, -0.4, 4);
                scene.add(textMesh2);
            });
        });

        // Camera position
        camera.position.x = -7;
        camera.position.y = 7;
        camera.position.z = -7;
        camera.lookAt(scene.position);

        // Resize on window size change
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            // Обновление размеров камеры
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Обновление размеров рендерера
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        const light = new THREE.PointLight(0xFFFFFF, 70, 1000);
        light.position.set(0, 5, 0);
        scene.add(light);

    </script>
</body>
</html>
